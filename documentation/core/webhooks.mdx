---
title: Webhooks
---

Modem Pay's webhooks notify your server about key events, such as customer creation, payment intent updates, and successful charges. To receive and securely process these notifications, follow the steps outlined here for setting up, validating, and handling webhooks.

<Note>
You can generate your unique Modem Pay webhook secret in the Modem Pay dashboard under **_Developers > Webhooks_**.
</Note>

## Setting Up Webhooks  

1. **Define Your Webhook Endpoint**:  
   Create a dedicated `POST` endpoint on your server to receive webhook events from Modem Pay. Ensure this endpoint is accessible over HTTPS to maintain security.

2. **Listening for Events**:  
   Your endpoint will receive a variety of event notifications (e.g., `customer.created`, `payment_intent.created`, `charge.succeeded`). The event type is provided in the `event` field, while the main data is within the `payload`.  


## Webhook Security and Signature Validation  

To confirm the integrity of incoming events, Modem Pay includes a unique `x-modem-signature` header in each webhook request. This header allows you to verify that the event originated from Modem Pay.  

1. **Retrieve the Signature**:  
   In your webhook endpoint, extract the `x-modem-signature` header from the incoming request.  

2. **Use `modempay.webhooks.composeEventDetails` for Validation**:  
   Pass the payload, signature, and your unique Modem Pay secret to the `modempay.webhooks.composeEventDetails` function. This function performs the necessary checks, verifying the signature and parsing the payload.  


<CodeGroup>
```javascript sdk
// Example usage
const event = modempay.webhooks.composeEventDetails(
    payload,
    xSignatureHeader,
    modemSecret
);
```
```javascript javascript
app.post("/modem-webhook", (req, res) => {
  const payload = JSON.stringify(req.body);
  const signature = req.headers["x-modem-signature"];

  // Ensure the signature is provided
  if (!signature) {
    return res.status(400).json({ message: "Signature missing" });
  }

  const secretHash = process.env.MODEM_PAY_SECRET_HASH;

  // Generate the HMAC-SHA256 hash for signature comparison
  const computedSignature = crypto
    .createHmac("sha256", secretHash)
    .update(payload)
    .digest("hex");

  // Ensure the signature length matches to avoid timing attacks
  if (computedSignature.length !== signature.length) {
    return res.status(400).json({ message: "Invalid signature length" });
  }

  // Use timing-safe comparison to protect against timing attacks
  if (
    !crypto.timingSafeEqual(
      Buffer.from(computedSignature),
      Buffer.from(signature)
    )
  ) {
    return res.status(400).json({ message: "Invalid signature!" });
  }

  // Parse the payload to handle the event
  try {
    const eventPayload = JSON.parse(payload);
    // You can add logic here to process the eventPayload
    res.sendStatus(200); // Acknowledge successful receipt
  } catch (error) {
    res.status(400).json({ message: "Invalid event data" });
  }
});
```
```python python
app = Flask(__name__)

@app.route("/modem-webhook", methods=["POST"])
def modem_webhook():
    payload = json.dumps(request.json)
    signature = request.headers.get("x-modem-signature")

    # Ensure the signature is provided
    if not signature:
        return jsonify({"message": "Signature missing"}), 400

    secret_hash = os.environ.get("MODEM_PAY_SECRET_HASH")

    # Generate the HMAC-SHA256 hash for signature comparison
    computed_signature = hmac.new(
        secret_hash.encode(), payload.encode(), hashlib.sha256
    ).hexdigest()

    # Ensure the signature length matches to avoid timing attacks
    if len(computed_signature) != len(signature):
        return jsonify({"message": "Invalid signature length"}), 400

    # Use timing-safe comparison to protect against timing attacks
    if not hmac.compare_digest(computed_signature, signature):
        return jsonify({"message": "Invalid signature!"}), 400

    # Parse the payload to handle the event
    try:
        event_payload = json.loads(payload)
        # Logic to process the eventPayload can go here
        return "", 200  # Acknowledge successful receipt
    except json.JSONDecodeError:
        return jsonify({"message": "Invalid event data"}), 400

if __name__ == "__main__":
    app.run(debug=True)
```
```php php
$secretHash = getenv("MODEM_PAY_SECRET_HASH");

if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $payload = json_encode(file_get_contents("php://input"));
    $signature = $_SERVER["HTTP_X_MODEM_SIGNATURE"];

    // Ensure the signature is provided
    if (!$signature) {
        http_response_code(400);
        echo json_encode(["message" => "Signature missing"]);
        exit();
    }

    // Generate the HMAC-SHA256 hash for signature comparison
    $computedSignature = hash_hmac('sha256', $payload, $secretHash);

    // Ensure the signature length matches to avoid timing attacks
    if (strlen($computedSignature) !== strlen($signature)) {
        http_response_code(400);
        echo json_encode(["message" => "Invalid signature length"]);
        exit();
    }

    // Use timing-safe comparison to protect against timing attacks
    if (!hash_equals($computedSignature, $signature)) {
        http_response_code(400);
        echo json_encode(["message" => "Invalid signature!"]);
        exit();
    }

    // Parse the payload to handle the event
    $eventPayload = json_decode($payload, true);

    if (json_last_error() !== JSON_ERROR_NONE) {
        http_response_code(400);
        echo json_encode(["message" => "Invalid event data"]);
        exit();
    }

    // Logic to process the eventPayload can go here
    http_response_code(200);  // Acknowledge successful receipt
    echo "";
}
```
</CodeGroup>

## Modem Pay CLI  

The Modem Pay CLI is a tool designed to simplify integration testing by offering features like authentication, webhook management, and event simulation **only in a test environment**.  


### Installation  
<Note>
Ensure that both Node.js and npm are installed on your machine before proceeding.
</Note>
To install the Modem Pay CLI, run:  
```bash bash 
npm install -g modem-pay-cli  
```  

### Commands  

#### **1. Login**  
Authenticates a user and generates an access token, business ID, and account ID. Authentication is required to access other CLI features.  

**Usage**:  
```bash bash 
$ modempay login 

âœ” Enter your Modem Pay email: â€º mercury@modempay.com
âœ” Enter your password: â€º *******
âœ… Login successful! Credentials saved.
```  

#### **2. Listen**  
The `listen` command creates a secure public tunnel using **Localtunnel** to forward webhooks to a local endpoint. This is particularly useful for testing webhooks during development.  

**Disclaimer**:  
- The CLI leverages **Localtunnel** to generate the public URL. In some cases, a public URL might not be provisioned successfully due to network issues.  
- This feature should **only** be used in **test environments**.  

**Usage**:  
```bash bash 
$ modempay listen --forward-url <local-endpoint>  
```  

**Options**:  
- `--forward-url`: Specifies your local endpoint to receive webhook events.  

**Example**:  
```bash bash 
$ modempay listen --forward-url=http://localhost:3000/webhook  

Ready! Your webhook signing secret is '{{WEBHOOK_SIGNING_SECRET}}' (^C to quit)
```  
This will create a public tunnel pointing to `http://localhost:3000/webhook`.  



#### **3. Trigger**  
Simulates events for testing purposes.  

**Usage**:  
```bash bash 
$ modempay trigger <event-type>  
```  

**Supported Event Types**:  
- **Customer Events**: `"customer.created"`, `"customer.updated"`, `"customer.deleted"`
- **Payment Intent Events**: `"payment_intent.created"`, `"payment_intent.cancelled"`
- **Charge Events**: `"charge.succeeded"`, `"charge.cancelled"`, `"charge.created"`, `"charge.updated"`


<Note>
The `listen` command captures both manually triggered events and automatically triggered events from the Modem Pay system. For testing purposes, always use the webhook secret generated by the listen command. This secret is displayed in the terminal and can also be found in the Modem Pay dashboard, but only in test mode. 

**Important**: Production secrets and endpoints remain unaffected and are not impacted by the test mode configuration.
</Note>

**Example**:  
```bash bash 
$ modempay trigger charge.succeeded 

ðŸ”§ Executing event: "charge.succeeded"
âœ… Event "charge.succeeded" triggered successfully.
```  
This sends a `charge.succeeded` event payload to the configured webhook endpoint for testing.  


<Tip>
Always respond to webhook events with an HTTP `200 OK` status to confirm receipt. This ensures Modem Pay doesnâ€™t retry the webhook unnecessarily.  
</Tip>

### Event Structure

Upon successful validation, `modempay.webhooks.composeEventDetails` returns an `Event` object containing the event type and payload data. The event types you may receive include:

- **Customer Events**: `"customer.created"`, `"customer.updated"`, `"customer.deleted"`
- **Payment Intent Events**: `"payment_intent.created"`, `"payment_intent.cancelled"`
- **Charge Events**: `"charge.succeeded"`, `"charge.cancelled"`, `"charge.created"`, `"charge.updated"`

### Example Usage

Hereâ€™s an example of using `modempay.webhooks.composeEventDetails` to handle incoming webhooks in a Node.js application:

<CodeGroup>
```javascript nodejs
const express = require("express");
const bodyParser = require("body-parser");
const ModemPay = require("modem-pay");

const modempay = new ModemPay();
const app = express();
app.use(bodyParser.json());

app.post("/webhook", (req, res) => {
  const payload = req.body;
  const signature = req.headers["x-modem-signature"];
  const secret = process.env.MODEM_WEBHOOK_SECRET;

  try {
    const event = modempay.webhooks.composeEventDetails(payload, signature, secret);
    // Process the event
    switch (event.event) {
      case "customer.created":
        // Handle new customer logic
        break;
      case "charge.succeeded":
        // Process successful payment
        break;
      // Add other cases as needed
    }

    res.status(200).send("Webhook processed!");
  } catch (error) {
    res.status(400).send("Invalid signature!");
  }
});

app.listen(3000, () => console.log("Listening for webhooks on port 3000"));
```
</CodeGroup>


### Recommended Response

For each webhook event, respond to Modem Pay with an HTTP `200 OK` status as confirmation. This ensures Modem Pay wonâ€™t re-send the event unless there's an error response.

<Warning>
Ensure your webhook endpoint quickly responds with an HTTP `200 OK` status before performing any tasks that might cause delays or timeouts, such as updating records or sending invoices. This prevents webhook retries and ensures smooth processing.
</Warning>

### Summary

By following these steps, you can securely receive and process webhook events from Modem Pay, automating actions based on customer interactions and payment flows. Make sure to store and securely handle the event data, as each event may carry critical transaction or customer information relevant to your application.
